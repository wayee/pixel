package mm.pixel{	import flash.display.BitmapData;	import flash.geom.Point;	import flash.geom.Rectangle;		import mm.pixel.effects.DefaultEffect;	import mm.pixel.effects.IEffect;	import mm.pixel.utils.PxG;
		/**	 * 层	 * @author Andy Cai <huayicai@gmail.com>	 * 	 */	public class PxLayer	{			private var items:Array 		= new Array();		private var pos:Point 			= new Point();		private var _effect:IEffect 	= new DefaultEffect();		private var camPoint:Point 		= PxG.camera.basePoint;		private var _useParallax:Boolean;		private var _renderer:PxRender;		private var width:int;		private var height:int;		public var bitmapData:BitmapData;		public var rect:Rectangle;				public function PxLayer()		{		}				public function get effect():IEffect		{			return _effect;		}		public function set effect( value:IEffect ):void		{			_effect = value;			if ( _renderer )			{				_effect.init( rect );			}		}				public function set renderer( value:PxRender ):void		{			_renderer = value;		}		public function get renderer():PxRender		{			return _renderer;		}				public function setSize( width:int, height:int ):void		{			bitmapData = new BitmapData( width, height, true, 0 );			rect = bitmapData.rect;			this.width = bitmapData.width;			this.height = bitmapData.height;			_effect.init(rect);		}				public function addItem( item:PxObject ):void		{			items.push( item );			item.layer = this;		}				public function removeItem( item:PxObject ):Boolean		{			for ( var i:int; i < items.length; i++ )			{				if ( items[i] == item )				{					items.splice ( i, 1 );					return true;				}			}			return false;		}				public function getDepth( item:PxObject ):int		{			return items.indexOf( item );		}				public function swapDepths( item1:PxObject, item2:PxObject ):void		{			var index1:int = items.indexOf( item1 );			var index2:int = items.indexOf( item2 );			items[index1] = item2;			items[index2] = item1;		}				public function get numChildren():int		{			return items.length;		}				/**		 * 渲染当前层所有对象		 */		public function render():void		{				_effect.preRender( bitmapData );			bitmapData.lock();			var length:int = items.length;			for ( var i:int = 0; i < length; i++ )			{				var item:PxObject = items[ int(i) ];								pos.x = Math.ceil( item.globalX + camPoint.x );				pos.y = Math.ceil( item.globalY + camPoint.y );							if( ( pos.x > -item.width && pos.x < width + item.width ) && ( pos.y > -item.height && pos.y < height + item.height ) )				{					item.update();					bitmapData.copyPixels( item.bitmapData, item.rect, pos, null, null, true );				}			}			bitmapData.unlock();						_effect.postRender( bitmapData );		} 	}}