package mm.pixel{	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.geom.Point;	import flash.geom.Rectangle;		import mm.pixel.utils.PxG;
		/**	 * 渲染器 	 * @author Andy Cai <huayicai@gmail.com>	 * 	 */	public class PxRender extends Bitmap	{			private var layers:Vector.<PxLayer> = new Vector.<PxLayer>;		private var layerLength:int;		private var rect:Rectangle;		public var hasBG:Boolean = false;				private const ZERO_POINT:Point = new Point();		public function PxRender( width:int, height:int )		{					bitmapData = new BitmapData( width, height );			rect = bitmapData.rect;		}				public function set cameraTarget( value:Point ):void		{			PxG.camera.target = value;		}		public function get cameraTarget():Point		{			return PxG.camera.target;		}				public function set cameraBoundry( value:Rectangle ):void		{			value.x = bitmapData.width >> 1;			value.y = bitmapData.height >> 1;			value.width -= bitmapData.width;			value.height -= bitmapData.height;			PxG.camera.boundary = value;		}		public function get cameraBoundry():Rectangle		{			return PxG.camera.boundary;		}				public function set cameraEase( value:Number ):void		{			PxG.camera.ease = value;		}		public function get cameraEase():Number		{			return PxG.camera.ease;		}				public function addLayer ( layer:PxLayer ):void		{			layers.push( layer );			layer.renderer = this;			layer.setSize( bitmapData.width, bitmapData.height );		}				public function removeLayer ( layer:PxLayer ):Boolean		{			for ( var i:int = 0; i < layers.length; i++ )			{				if ( layers[i] == layer )				{					layers.splice( i, 1 );					return true;				}			}			return false;		}		public function getLayerDepth( layer:PxLayer ):int		{			return layers.indexOf( layer );		}				public function swapLayers( layer1:PxLayer, layer2:PxLayer ):void		{			var index1:int = layers.indexOf( layer1 );			var index2:int = layers.indexOf( layer2 );			layers[index1] = layer1;			layers[index2] = layer2;		}		public function get numLayers():int		{			return layers.length;		}		public function render ():void		{			PxG.camera.scroll();						bitmapData.lock();						if ( !hasBG )			{				bitmapData.fillRect( rect, 0x00000000 );			}						layerLength = layers.length;			for ( var i:int = 0; i < layerLength; i++ )			{				var layer:PxLayer = layers[int(i)];				layer.render();				bitmapData.copyPixels( layer.bitmapData, rect, ZERO_POINT, null, null, true );			}						bitmapData.unlock();		} 	}}