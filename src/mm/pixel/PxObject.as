package mm.pixel{	import flash.display.BitmapData;	import flash.events.EventDispatcher;	import flash.geom.Point;	import flash.geom.Rectangle;		import mm.pixel.utils.PxG;	import mm.pixel.utils.PxU;
	/**	 * 类似Sprite 	 * @author Andy Cai <huayicai@gmail.com>	 * 	 */	public class PxObject extends EventDispatcher	{		/**		 * 注册点 		 */		public static const HOTSPOT_CUSTOM:String = "hotspotCustom";		public static const HOTSPOT_TOP_LEFT:String = "hotspotTopLeft";		public static const HOTSPOT_TOP_CENTER:String = "hotspotTopCenter";		public static const HOTSPOT_TOP_RIGHT:String = "hotspotTopRight";		public static const HOTSPOT_LEFT_MIDDLE:String = "hotspotLeftMiddle";		public static const HOTSPOT_CENTER:String = "hotspotCenter";		public static const HOTSPOT_RIGHT_MIDDLE:String = "hotspotRightMiddle";		public static const HOTSPOT_BOTTOM_LEFT:String = "hotspotBottomLeft";		public static const HOTSPOT_BOTTOM_CENTER:String = "hotspotBottomCenter";		public static const HOTSPOT_BOTTOM_RIGHT:String = "hotspotBottomRight";				protected const ZERO_POINT:Point = new Point();				protected var _layer:PxLayer;		protected var collisionRect:Rectangle = new Rectangle();				public var x:Number 	= 0;		public var y:Number 	= 0;		public var width:int 	= 0;		public var height:int 	= 0;				protected var top:int;		protected var bottom:int;		protected var left:int;		protected var right:int;		public var smoothing:Boolean = false;		public var bitmapData:BitmapData;		public var rect:Rectangle;		public var hotspotX:int = 0;		public var hotspotY:int = 0;		private var hotspotType:String;		private var updated:Boolean;				/**		 * 加速度 		 */				public var vx:Number;		public var vy:Number;						public function PxObject()		{  			rect 	= bitmapData.rect;			width 	= bitmapData.width;			height 	= bitmapData.height;						top 	= y;			bottom 	= top + height;			left 	= x;			right 	= left + width;			updated = true;						hotspot(HOTSPOT_CENTER);		}				/**		 * 设置注册点 		 * @param location		 * 		 */		public function hotspot(location:String):void		{			hotspotType = location;						switch (location)			{				case HOTSPOT_TOP_LEFT:					hotspotX = left;					hotspotY = top;					break;								case HOTSPOT_TOP_CENTER:					hotspotX = left + (width / 2);					hotspotY = top;					break;								case HOTSPOT_TOP_RIGHT:					hotspotX = right;					hotspotY = top;					break;								case HOTSPOT_LEFT_MIDDLE:					hotspotX = left;					hotspotY = top + (height / 2);					break;								case HOTSPOT_CENTER:					hotspotX = -(left + (width / 2));					hotspotY = -(top + (height / 2));					break;								case HOTSPOT_RIGHT_MIDDLE:					hotspotX = right;					hotspotY = top + (height / 2);					break;								case HOTSPOT_BOTTOM_LEFT:					hotspotX = left;					hotspotY = bottom;					break;								case HOTSPOT_BOTTOM_CENTER:					hotspotX = left + (width / 2);					hotspotY = bottom;					break;								case HOTSPOT_BOTTOM_RIGHT:					hotspotX = right;					hotspotY = bottom;					break;								default:					hotspotType = HOTSPOT_CUSTOM;			}		}				public function get globalX():int		{			if (hotspotX >= 0)			{				return x + hotspotX;			}			else			{				return x - Math.abs(hotspotX);			}		}				public function get globalY():int		{			if (hotspotY >= 0)			{				return y + hotspotY;			}			else			{				return y - Math.abs(hotspotY);			}		}				public function hasUpdated():Boolean		{			return updated;		}				public function reset():void		{			updated = false;		}				public function set layer( value:PxLayer ):void		{			_layer = value;		}				public function get depth():int		{			return _layer.getDepth( this );			}				public function getCollision( object:PxObject ):Boolean		{			if ( bitmapData.hitTest( new Point(x, y), 1, object.bitmapData, new Point( object.x, object.y), 1 ) )			{				return true;			}			return false;		}				public function getCollisionPoint( point:Point ):Boolean		{			collisionRect.x = globalX + PxG.camera.basePoint.x;			collisionRect.y = globalY + PxG.camera.basePoint.y;			collisionRect.width = width;			collisionRect.height = height;			if ( collisionRect.containsPoint( point ) )			{				return true;			}			return false;		}				public function dispose():void		{			bitmapData = null;			_layer.removeItem( this );		}				public function update():void 		{			rect 	= bitmapData.rect;			width 	= bitmapData.width;			height 	= bitmapData.height;			top 	= y;			bottom 	= y + height;			left 	= x;			right 	= x + width;			updated = true;		}				/**		 * 是否在屏幕内 		 * @return bool		 * 		 */		public function onScreen():Boolean		{			return (x + width > PxG.camera.boundary.x) 			&& (y + height > PxG.camera.boundary.y)				&& (x < PxG.camera.boundary.right)				&& (y < PxG.camera.boundary.bottom);		}				override public function toString():String		{			return PxU.getClassName(this, true);		}	}}